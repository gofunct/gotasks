package grpc

import (
	"crypto/tls"
	"crypto/x509"
	"github.com/go-pg/pg"
	"github.com/gofunct/service/runtime/api/todo"
	api "github.com/gofunct/service/runtime/api/todo/v1"
	"github.com/gofunct/service/runtime/logging"
	vi "github.com/gofunct/service/runtime/viper"
	"github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/recovery"
	"github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
	"github.com/grpc-ecosystem/go-grpc-prometheus"
	"github.com/opentracing/opentracing-go"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/status"
	"net"
	"net/http"
	"net/http/pprof"
	stack "runtime"
	"strings"
	"time"
)

var log = logging.Log(true)

func Serve() func(cmd *cobra.Command, args []string) {
	return func(cmd *cobra.Command, args []string) {
		lis, err := net.Listen("tcp", vi.VString("grpc_port"))
		if err != nil {
			log.Fatal("Failed to listen:"+vi.VString("grpc_port"), err)
		}
		tracer, closer, err := Trace(log.JZap)
		if err != nil {
			log.Fatal("Cannot initialize Jaeger Tracer %s", zap.Error(err))
		}
		defer closer.Close()

		// Set GRPC Interceptors
		server := NewServer(tracer)

		api.RegisterTodoServiceServer(server, &todo.Service{DB: NewDB()})

		mux := NewMux()
		log.Zap.Debug("Starting debug service..", zap.String("grpc_debug_port", vi.VString("grpc_debug_port")))
		go func() { http.ListenAndServe(vi.VString("grpc_debug_port"), mux) }()

		log.Zap.Debug("Starting grpc service..", zap.String("grpc_port", vi.VString("grpc_port")))
		server.Serve(lis)
	}
}

// Panic handler prints the stack trace when recovering from a panic.
var panicHandler = grpc_recovery.RecoveryHandlerFunc(func(p interface{}) error {
	buf := make([]byte, 1<<16)
	stack.Stack(buf, true)
	log.Zap.Error("recovery-handler", zap.String("panic recovered: ", string(buf)))
	return status.Errorf(codes.Internal, "%s", p)
})

func NewMux() *http.ServeMux {
	mux := http.NewServeMux()
	mux.Handle("/metrics", promhttp.Handler())
	mux.Handle("/debug/pprof/", http.HandlerFunc(pprof.Index))
	mux.Handle("/debug/pprof/cmdline", http.HandlerFunc(pprof.Cmdline))
	mux.Handle("/debug/pprof/profile", http.HandlerFunc(pprof.Profile))
	mux.Handle("/debug/pprof/symbol", http.HandlerFunc(pprof.Symbol))
	mux.Handle("/debug/pprof/trace", http.HandlerFunc(pprof.Trace))

	return mux
}

func NewDB() *pg.DB {
	db := pg.Connect(&pg.Options{
		User:                  vi.VString("db_user"),
		Password:              vi.VString("db_pass"),
		Database:              vi.VString("db_name"),
		Addr:                  vi.VString("db_host") + vi.VString("db_port"),
		RetryStatementTimeout: true,
		MaxRetries:            4,
		MinRetryBackoff:       250 * time.Millisecond,
	})

	// Create Table from Todo struct generated by gRPC
	db.CreateTable(&api.Todo{}, nil)
	return db
}

func NewServer(tracer opentracing.Tracer) *grpc.Server {
	interceptor := NewMetricsIntercept()
	grpc_zap.ReplaceGrpcLogger(zap.L())
	zopts := []grpc_zap.Option{
		grpc_zap.WithDurationField(func(duration time.Duration) zapcore.Field {
			return zap.Int64("grpc.time_ns", duration.Nanoseconds())
		}),
	}
	// Make sure that log statements internal to gRPC library are logged using the zapLogger as well.
	grpc_zap.ReplaceGrpcLogger(zap.L())
	s := grpc.NewServer(
		grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
			grpc_opentracing.StreamServerInterceptor(grpc_opentracing.WithTracer(tracer)),
			interceptor.StreamServer(),
			grpc_zap.StreamServerInterceptor(zap.L(), zopts...),
			grpc_recovery.StreamServerInterceptor(grpc_recovery.WithRecoveryHandler(panicHandler)),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)),
			grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(tracer)),
			interceptor.UnaryServer(),
			grpc_zap.UnaryServerInterceptor(zap.L(), zopts...),
			grpc_recovery.UnaryServerInterceptor(grpc_recovery.WithRecoveryHandler(panicHandler)),
		)),
	)

	grpc_health_v1.RegisterHealthServer(s, health.NewServer())
	grpc_prometheus.Register(s)
	RegisterMetricsIntercept(s, interceptor)
	return s
}

func GrpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	})
}

func RegisterCertificates(cert, key string) (*tls.Certificate, *x509.CertPool) {
	var err error
	pair, err := tls.X509KeyPair([]byte(cert), []byte(key))
	if err != nil {
		panic(err)
	}

	pool := x509.NewCertPool()
	ok := pool.AppendCertsFromPEM([]byte(cert))
	if !ok {
		panic("bad certs")
	}
	return &pair, pool
}
